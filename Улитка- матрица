Выведите таблицу размером n×n n \times n n×n, заполненную числами от 1 1 1 до n2 n^2 n2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5 n=5 n=5):

Sample Input:

5

Sample Output:

1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9


# Решение
n = int(input())

# Создаем матрицу, заполненую нулями
matrix = [[0 for i in range(n)] for j in range(n)]

# Определяем внутренние счетчики для цикла
row = 0  # строки
col = 0  # столбцы
x = 1  # текущее значение для заполнения ячейки
k = 0  # порядковый номер контура

while x <= n*n:
    matrix[row][col] = x  # заполняем ячейку текущим значением

    if row != col:  # Только если мы сейчас не на диагонали!
        # Сумма зеркально расположенных элементов одинакова для текущего контура.
        # Она равна нижнему правому значению в контуре, умноженному на 2.
        # Так что на каждом шаге цикла мы заполняем зеркальный элемент матрицы,
        # просто вычитая текущее x из этой суммы
        matrix[col][row] = (matrix[k][k] + (n-k*2)*2) * 2 - 4 - x

    if col != n-k-1:
        # если еще не уперлись в правую границу контура, двигаемся вправо
        col += 1

    elif row != n-k-1:
        # если еще не уперлись в нижнюю границу контура, двигаемся вниз
        row += 1

    elif x != n*n:
        # Если вправо и вниз уже нельзя, значит мы закончили обход текущего контура!
        # Только не забываем проверить, что x не равен n*n, а то будет бо-бо.
        k += 1  # переходим к следующему контуру
        row = col = k  # обход следующего контура начнем с координат [k,k]
        x = matrix[k][k-1]  # текущее значение равно наибольшему в старом контуре

    # Ну, и не забываем прибавлять единичку в конце цикла, какое бы условие ни сработало.
    x += 1

# Выводим на печать
for i in matrix:
    print(*i)

